@article{10.1145/363347.363387,
author = {Thompson, Ken},
title = {Programming Techniques: Regular Expression Search Algorithm},
year = {1968},
issue_date = {June 1968},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {11},
number = {6},
issn = {0001-0782},
url = {https://doi.org/10.1145/363347.363387},
doi = {10.1145/363347.363387},
abstract = {A method for locating specific character strings embedded in character text is described and an implementation of this method in the form of a compiler is discussed. The compiler accepts a regular expression as source language and produces an IBM 7094 program as object language. The object program then accepts the text to be searched as input and produces a signal every time an embedded string in the text matches the given regular expression. Examples, problems, and solutions are also presented.},
journal = {Commun. ACM},
month = {jun},
pages = {419–422},
numpages = {4},
keywords = {search, match, regular expression}
},
@article{test_article,
    author  = "George D. Greenwade",
    title   = "The {C}omprehensive {T}ex {A}rchive {N}etwork ({CTAN})",
    year    = "1993",
    journal = "TUGBoat",
    volume  = "14",
    number  = "3",
    pages   = "342--351"
},

@INPROCEEDINGS{7503707,
  author={Scalabrino, Simone and Linares-Vásquez, Mario and Poshyvanyk, Denys and Oliveto, Rocco},
  booktitle={2016 IEEE 24th International Conference on Program Comprehension (ICPC)}, 
  title={Improving code readability models with textual features}, 
  year={2016},
  volume={},
  number={},
  pages={1-10},
  doi={10.1109/ICPC.2016.7503707}},

  @INPROCEEDINGS{7474473,
  author={Sedano, Todd},
  booktitle={2016 IEEE 29th International Conference on Software Engineering Education and Training (CSEET)}, 
  title={Code Readability Testing, an Empirical Study}, 
  year={2016},
  volume={},
  number={},
  pages={111-117},
  doi={10.1109/CSEET.2016.36}},

@misc{zhou2017completely,
      title={Completely Automated Equivalence Proofs}, 
      author={Qi Zhou and David Heath and William Harris},
      year={2017},
      eprint={1705.03110},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
},

@Inbook{Strichman2008,
author="Strichman, Ofer
and Godlin, Benny",
editor="Meyer, Bertrand
and Woodcock, Jim",
title="Regression Verification - A Practical Way to Verify Programs",
bookTitle="Verified Software: Theories, Tools, Experiments: First IFIP TC 2/WG 2.3 Conference, VSTTE 2005, Zurich, Switzerland, October 10-13, 2005, Revised Selected Papers and Discussions",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="496--501",
isbn="978-3-540-69149-5",
doi="10.1007/978-3-540-69149-5_54",
url="https://doi.org/10.1007/978-3-540-69149-5_54"
},

@InProceedings{10.1007/978-3-540-78800-3_24,
author="de Moura, Leonardo
and Bj{\o}rner, Nikolaj",
editor="Ramakrishnan, C. R.
and Rehof, Jakob",
title="Z3: An Efficient SMT Solver",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="337--340",
abstract="Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.",
isbn="978-3-540-78800-3"
},

@INPROCEEDINGS{4812745,
  author={Tsantalis, Nikolaos and Chatzigeorgiou, Alexander},
  booktitle={2009 13th European Conference on Software Maintenance and Reengineering}, 
  title={Identification of Extract Method Refactoring Opportunities}, 
  year={2009},
  volume={},
  number={},
  pages={119-128},
  doi={10.1109/CSMR.2009.23}},


  @INPROCEEDINGS{6178876,
  author={Hotta, Keisuke and Higo, Yoshiki and Kusumoto, Shinji},
  booktitle={2012 16th European Conference on Software Maintenance and Reengineering}, 
  title={Identifying, Tailoring, and Suggesting Form Template Method Refactoring Opportunities with Program Dependence Graph}, 
  year={2012},
  volume={},
  number={},
  pages={53-62},
  doi={10.1109/CSMR.2012.16}},

  @article{DJUKANOVIC2020106499,
title = {Finding Longest Common Subsequences: New anytime A∗ search results},
journal = {Applied Soft Computing},
volume = {95},
pages = {106499},
year = {2020},
issn = {1568-4946},
doi = {https://doi.org/10.1016/j.asoc.2020.106499},
url = {https://www.sciencedirect.com/science/article/pii/S1568494620304385},
author = {Marko Djukanovic and Günther R. Raidl and Christian Blum},
keywords = {Longest common subsequence problem, Hybrid metaheuristic, A search, Beam search, Anytime column search},
abstract = {The Longest Common Subsequence (LCS) problem aims at finding a longest string that is a subsequence of each string from a given set of input strings. This problem has applications, in particular, in the context of bioinformatics, where strings represent DNA or protein sequences. Existing approaches include numerous heuristics, but only a few exact approaches, limited to rather small problem instances. Adopting various aspects from leading heuristics for the LCS, we first propose an exact A∗ search approach, which performs well in comparison to earlier exact approaches in the context of small instances. On the basis of A∗ search we then develop two hybrid A∗–based algorithms in which classical A∗ iterations are alternated with beam search and anytime column search, respectively. A key feature to guide the heuristic search in these approaches is the usage of an approximate expected length calculation for the LCS of uniform random strings. Even for large problem instances these anytime A∗ variants yield reasonable solutions early during the search and improve on them over time. Moreover, they terminate with proven optimality if enough time and memory is given. Furthermore, they yield upper bounds and, thus, quality guarantees when terminated early. We comprehensively evaluate the proposed methods using most of the available benchmark sets from the literature and compare to the current state-of-the-art methods. In particular, our algorithms are able to obtain new best results for 82 out of 117 instance groups. Moreover, in most cases they also provide significantly smaller optimality gaps than other anytime algorithms.}
},

@inproceedings{inproceedings,
author = {Khan, Afsana and Aesha, Afrida and Sarker, Juthi},
year = {2019},
month = {01},
pages = {},
title = {A New Algorithmic Approach to Finding Minimum Spanning Tree},
doi = {10.1109/CEEICT.2018.8628095}
},

@inproceedings{10.1145/3377811.3380922,
author = {Zhong, Hao and Meng, Na and Li, Zexuan and Jia, Li},
title = {An Empirical Study on API Parameter Rules},
year = {2020},
isbn = {9781450371216},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3377811.3380922},
doi = {10.1145/3377811.3380922},
abstract = {Developers build programs based on software libraries to reduce coding effort. If a program inappropriately sets an API parameter, the program may exhibit unexpected runtime behaviors. To help developers correctly use library APIs, researchers built tools to mine API parameter rules. However, it is still unknown (1) what types of parameter rules there are, and (2) how these rules distribute inside documents and source files. In this paper, we conducted an empirical study to investigate the above-mentioned questions. To analyze as many parameter rules as possible, we took a hybrid approach that combines automatic localization of constrained parameters with manual inspection. Our automatic approach---PaRu---locates parameters that have constraints either documented in Javadoc (i.e., document rules) or implied by source code (i.e., code rules). Our manual inspection (1) identifies and categorizes rules for the located parameters, and (2) establishes mapping between document and code rules. By applying PaRu to 9 widely used libraries, we located 5,334 parameters with either document or code rules. Interestingly, there are only 187 parameters that have both types of rules, and 79 pairs of these parameter rules are unmatched. Additionally, PaRu extracted 1,688 rule sentences from Javadoc and code. We manually classified these sentences into six categories, two of which are overlooked by prior approaches. We found that 86.2% of parameters have only code rules; 10.3% of parameters have only document rules; and only 3.5% of parameters have both document and code rules. Our research reveals the challenges for automating parameter rule extraction. Based on our findings, we discuss the potentials of prior approaches and present our insights for future tool design.},
booktitle = {Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering},
pages = {899–911},
numpages = {13},
location = {Seoul, South Korea},
series = {ICSE '20}
}
}
